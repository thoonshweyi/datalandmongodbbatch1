
mongosh
use lessonone
show collections
db.getCollectionInfos()

db.officestaffs.insertMany([
    {_id:1,name:"Aung Aung", dept:"IT",salary:400000,city:"Yangon"},
    {_id:2,name:"Su Su", dept:"HR",salary:350000,city:"Yangon"},
    {_id:3,name:"Zaw Zaw", dept:"IT",salary:700000,city:"Yangon"},
    {_id:4,name:"Ni Ni", dept:"Finance",salary:250000,city:"Yangon"},
    {_id:5,name:"Kyaw Kyaw", dept:"IT",salary:550000,city:"Yangon"},
])

=> System Variables
db.officestaffs.find()

= $$ROOT (return the entire document)

db.officestaffs.aggregate([
    {
        $project:{
            name:1,
            fullDocument: "$$ROOT"
        }
    }
])


= $$CURRENT (same as $salary in the simple case)

db.officestaffs.aggregate([
    {
        $project:{
            salaryDouble:{
                $multiply: ["$$CURRENT.salary",2]
            }
        }
    }
])

= $$REMOVE ()

db.officestaffs.aggregate([
    {
        $project:{
            name:1,
            city: {
                $cond:{
                    if:{
                        $eq:["$city","Yangon"]
                    },
                    then: "$city",
                    else: "$$REMOVE"
                }
            }
        }
    }
])

db.officestaffs.aggregate([
    {
        $project:{
            name:1,
            city: {
                $cond:{
                    if:{
                        $ne:["$city","Yangon"]
                    },
                    then: "$city",
                    else: "$$REMOVE"
                }
            }
        }
    }
])

= $$NOW (timestamp)

db.officestaffs.aggregate([
    {
        $addFields:{
            createdAt:"$$NOW"
        }
    }
])
---------------------------------------------------------
=> User-defined Variables

    $let (in expressions)
    let ($lookup,$filter,$map,etc....)


=$let
{
    $let{
        vars:{variablename:<expression>},
        in:<expression that use the varialbes>:
    }
}

db.officestaffs.aggregate([
    {
        $project:{
           name:1,
           doubleSalary:{
                $let:{
                    vars: {original:"$salary"},
                    in: {
                        $multiply: ["$$original",2]
                    }
                }
           }
        }
    }
])

= let
db.onlinestudents.insertMany([
    {_id:1,name:"Aung Kyaw",scores:[50,80,90]},
    {_id:2,name:"Su Myat",scores:[40,80,100]},
    {_id:3,name:"Zaw Zaw",scores:[60,70,80]},
])

db.onlinestudents.insertMany([
    {_id:4,name:"NiNi",scores:[70,80,90]},
    {_id:5,name:"Yu Yu",scores:[50,60,70]},
])

db.enrollments.insertMany([
    {studentId:1,course:"MongoDB"},
    {studentId:2,course:"Nodejs"},
    {studentId:3,course:"Python"},
])
db.enrollments.insertMany([
    {studentId:1,course:"Python"},
])


=>without let
db.onlinestudents.aggregate({
    $project:{
        name:1,
        adjustScores:{
            $map:{
                input:"$scores",
                as: "score",
                in: {
                    $add:["$$score",10]
                }
            }
        }
    }
})


db.onlinestudents.aggregate([
    {
        $lookup:{
            from:"enrollments",
            let:{student_id:"$_id"},
            pipeline:[
                {
                    $match:{
                        $expr:{
                            $eq: ["$studentId","$$student_id"]
                        }
                    }
                }
            ],
            as:"enrolledCourses"
        }
    }
])


-----------------------------------------------------------------------
‚úÖ What is $let in MongoDB Aggregation?

$let allows you to:

1Ô∏è‚É£ Create temporary variables (vars) inside an expression
2Ô∏è‚É£ Use those variables inside the in block

It works the same way as let in JavaScript:

let x = 5;
let result = x * 2;


MongoDB version:

$let: {
    vars: { x: 5 },
    in: { $multiply: ["$$x", 2] }
}


‚úÖ 1. BASIC $lookup

Used when you want to join two collections using one field = one field (simple equality match).

‚úî Purpose

Perform a LEFT JOIN between two collections.

Match using direct equality.

‚úî Basic Structure
{
  $lookup: {
    from: "otherCollection",
    localField: "fieldInThisCollection",
    foreignField: "fieldInOtherCollection",
    as: "result"
  }
}

‚úî Example

Join products with categories:

{
  $lookup: {
    from: "categories",
    localField: "category_id",
    foreignField: "_id",
    as: "category_info"
  }
}

‚úî When to Use

One-to-one or one-to-many simple joins

No complex conditions

No pipeline needed

‚úÖ 2. ADVANCED $lookup (Pipeline Lookup)

Used when the relationship is complex, requires filtering, sorting, comparison, or joining on multiple fields.

‚úî Purpose

Perform advanced joins using:

multiple matching conditions

comparisons ($gt, $lt, $in)

additional pipelines

variables (let)

multiple fields join

nested lookups

‚úî Advanced Structure
{
  $lookup: {
    from: "otherCollection",
    let: { localVar: "$localField" },
    pipeline: [
      { $match: { $expr: { $eq: ["$foreignField", "$$localVar"] } } },
      { $sort: { created_at: -1 } },
      { $limit: 1 }
    ],
    as: "result"
  }
}

‚úî Example: Join with filter + sort + limit

Get only the latest order of each customer:

{
  $lookup: {
    from: "orders",
    let: { customerId: "$_id" },
    pipeline: [
      { $match: { $expr: { $eq: ["$customer_id", "$$customerId"] } } },
      { $sort: { created_at: -1 } },
      { $limit: 1 }
    ],
    as: "latest_order"
  }
}

üéØ Main Differences (Very Short)
Feature	Basic $lookup	Advanced $lookup
Join type	Simple equality	Complex conditions
Syntax	localField + foreignField	let + pipeline + $expr
Match on multiple fields	‚ùå No	‚úî Yes
Filtering & sorting	‚ùå No	‚úî Yes
Limit, group, project inside	‚ùå No	‚úî Yes
Performance control	Low	High (better tuning)